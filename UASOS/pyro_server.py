# pyro_server.py>
# Library used for opening Pyro4 server that will hold the script
# generated by scriptgen.py
# It starts from SRCTask as separated instance, SRCTask and NAVTask
# will hold in listening until the connection is established
# Author: Vincenzo Maria VITALE - DCAS - MS TAS AERO - FTE
###################################################################

import Pyro4 as pyro
import serpent
import base64
import threading
import psutil
from utilscsv import *
from copy import *
from packet import *
from scriptgen import script, script_s, script_n, script_ov


@pyro.expose
class PyroServer:
    def __init__(self):
        # initialize just the values but not start the server on init for now
        # Solve TIMEOUT issue:
        self.timeout_value = 86400  # 1yr in seconds

        self.server_up = False
        self.scr_dir = [script, script_s, script_n, script_ov]
        self.case = None
        self.MlastPacket = Packet()
        self.SRClastPacket = Packet()
        self.NAVlastPacket = Packet()
        self.clock = cClock()
        self.SRCPackOUT = False
        self.NAVPackOUT = True  # Init as both False, for now the NAV Packet is faked as arrived
        self.csv_prt = utilscsv()

        while not self.server_up:
            if len(self.scr_dir) != 0:  # It somehow waits the generation of the objects
                self.daemon = pyro.Daemon()
                self.uri = self.daemon.register(self)
                self.name_src = pyro.locateNS()
                self.name_src.register("pyro_svr", self.uri)

                self.server_up = True
                self.daemon.requestLoop()

    @pyro.expose
    def set_USER_info(self, USER_ID):
        self.csv_prt.USER_ID = USER_ID
        self.csv_prt.setup_out()
        return

    @pyro.expose
    def close(self, phase):
        # self.daemon.shutdown()
        if phase == 0:  # Close both result files
            self.csv_prt.close_file(0)
            self.csv_prt.close_file(1)
        elif phase == 1:  # Close the last result file remained
            self.csv_prt.close_file(1)

        for proc in psutil.process_iter():
            if proc.name() == 'pyro4-ns.exe':
                proc.terminate()
                print('Pyro4 server terminated')
                return

    @pyro.expose
    def check_status(self):
        return True

    @pyro.expose
    def start_time(self):
        self.clock.reset_time()
        return self.clock.get_time()
    # Remember: I'm seeing these function from the Task point of view

    @pyro.expose
    def get_time(self):
        return self.clock.get_time()

    def pause_time(self):
        self.clock.pause_time()
        return

    @pyro.expose
    def read_data(self, case, it: int):  # Here I should implement the difference in the lines to read
        # TODO Add here a stop of the sending and reset of the clock for the next phase
        if self.case is None:  # At init
            self.case = case
        # read line from server
        out_pack = Packet()
        out_pack.INorOUT = 0  # Inbound for the task
        out_pack.iter = it
        # writing of the pack selection in base on the phase
        if self.case == 1:  # MAIN PHASE
            ph = 0
        elif self.case == 2:  # SEARCH PHASE
            ph = 1
        elif self.case == 3:  # NAVI PHASE
            ph = 2
        elif self.case == 4:  # OVERALL PHASE
            ph = 3
        else:
            ph = 1  # Initial case
        out_pack.Tot_iters = len(self.scr_dir[ph].TIME)
        out_pack.Time = self.scr_dir[ph].TIME[it]
        out_pack.Switch = self.scr_dir[ph].SWITCH[it]
        out_pack.Task = self.scr_dir[ph].TASK[it]
        out_pack.case = None
        out_pack.Imgs = deepcopy(self.scr_dir[ph].IMGS[it])
        out_pack.Fils = deepcopy(self.scr_dir[ph].FILS[it])
        out_pack.Rots = deepcopy(self.scr_dir[ph].ROTS[it])
        out_pack.Corr = deepcopy(self.scr_dir[ph].CORS[it])
        # TODO: add NAV data

        if it != 0 and (it < out_pack.Tot_iters and self.case != 6):  # Exclude ending and pause cases
            out_pack.pImgs = deepcopy(self.scr_dir[ph].IMGS[it-1])

        elif it == out_pack.Tot_iters:
            out_pack.case = 8  # I REQUEST THE CALL FOR END
            # TODO CALL THE DAMN RESEEEEET OF THE CLOOOOOCK!
        elif self.case == 6:
            out_pack.case = 6  # Pause is then commanded!
            pass  # TODO Figure it out how I should pause the events!

        return serpent.dumps(out_pack)

    @pyro.expose
    def thread_send(self, in_pack):
        threading.Thread(target=self.send_data, args=(in_pack,)).start()  # this will generate a separate thread, avoiding stops
        return

    def send_data(self, inbound_pack):
        # send behavioral pack, remember to add the base64 decoding
        wrk_pack = Packet()
        dec_inpack = base64.b64decode(inbound_pack['data'])
        w_pack = serpent.loads(dec_inpack)

        # restructure the packet in the custom class
        wrk_pack.INorOUT = w_pack['INorOUT']  # Inbound for the task
        if wrk_pack.INorOUT == 1:
            self.SRCPackOUT = True  # Packet arrived from SRCTask
        elif wrk_pack.INorOUT == 2:
            self.NAVPackOUT = True  # Packet arrived from NAVTask

        wrk_pack.iter = w_pack['iter']
        wrk_pack.Tot_iters = w_pack['Tot_iters']
        wrk_pack.phase = w_pack['phase']
        wrk_pack.case = w_pack['case']
        self.case = w_pack['case']
        wrk_pack.Time = w_pack['Time']
        wrk_pack.Switch = w_pack['Switch']
        wrk_pack.Task = w_pack['Task']

        wrk_pack.Imgs = deepcopy(w_pack['Imgs'])
        wrk_pack.Fils = deepcopy(w_pack['Fils'])
        wrk_pack.Rots = deepcopy(w_pack['Rots'])
        wrk_pack.Corr = deepcopy(w_pack['Corr'])

        if wrk_pack.INorOUT == 1:
            wrk_pack.UserType = deepcopy(w_pack['UserType'])
            wrk_pack.RT = w_pack['RT']
            wrk_pack.SRCLatency = w_pack['SRCLatency']
            wrk_pack.Tnum = w_pack['Tnum']
            wrk_pack.GoodCh = w_pack['GoodCh']
            wrk_pack.OvCh = w_pack['OvCh']
            wrk_pack.OvTrue = w_pack['OvTrue']
            #wrk_pack.ACC = w_pack['ACC']
        elif wrk_pack.INorOUT == 2:
            # Missing other NAV params
            wrk_pack.Tstick = w_pack['Tstick']
            wrk_pack.NAVLatency = w_pack['NAVLatency']

        if wrk_pack.INorOUT == 1:
            del self.SRClastPacket
            self.SRClastPacket = deepcopy(wrk_pack)  # Packet arrived from SRCTask
        elif wrk_pack.INorOUT == 2:
            del self.NAVlastPacket
            self.NAVlastPacket = deepcopy(wrk_pack)  # Packet arrived from NAVTask

        if self.SRCPackOUT and self.NAVPackOUT:
            self.merge_packs()  # Executing as separate thread

        return

    def merge_packs(self):
        # Reinit the packet
        del self.MlastPacket
        self.MlastPacket = Packet()
        # Copy of the data
        self.MlastPacket.iter = self.SRClastPacket.iter
        self.MlastPacket.Tot_iters = self.SRClastPacket.Tot_iters
        self.MlastPacket.phase = self.SRClastPacket.phase
        self.MlastPacket.case = self.SRClastPacket.case
        self.MlastPacket.Time = self.SRClastPacket.Time
        self.MlastPacket.Switch = self.SRClastPacket.Switch
        # SRC Params
        self.MlastPacket.Task = deepcopy(self.SRClastPacket.Task)
        self.MlastPacket.Imgs = deepcopy(self.SRClastPacket.Imgs)
        self.MlastPacket.Fils = deepcopy(self.SRClastPacket.Fils)
        self.MlastPacket.Rots = deepcopy(self.SRClastPacket.Rots)
        self.MlastPacket.Corr = deepcopy(self.SRClastPacket.Corr)
        self.MlastPacket.UserType = deepcopy(self.SRClastPacket.UserType)
        self.MlastPacket.SRCLatency = self.SRClastPacket.SRCLatency
        self.MlastPacket.RT = self.SRClastPacket.RT
        self.MlastPacket.Tnum = self.SRClastPacket.Tnum
        self.MlastPacket.ACC = self.SRClastPacket.ACC
        self.MlastPacket.GoodCh = self.SRClastPacket.GoodCh
        self.MlastPacket.OvCh = self.SRClastPacket.OvCh
        self.MlastPacket.OvTrue = self.SRClastPacket.OvTrue
        # TODO NAV Params
        #self.MlastPacket.Tstick = self.NAVlastPacket.Tstick
        #self.MlastPacket.NAVLatency = self.NAVlastPacket.NAVLatency

        # TODO Overall computations
        #if self.MlastPacket.Switch == 3:
        #    self.MlastPacket.TTS = abs(self.SRClastPacket.Tnum-self.NAVlastPacket.Tstick)  # Time to Switch

        # Add routine to write on csv on separate process
        self.csv_prt.write_line(self.MlastPacket)

        # Reset Flags
        self.SRCPackOUT = False
        #self.NAVPackOUT = False # TODO

        return


pyro_svr = PyroServer()
